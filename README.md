# CURSO-DE-ALGORITMO
üë®‚Äç‚öñÔ∏èCURSO DE L√ìGICA DE PROGRAMA√á√ÉO COM PYTHON E PORTUGOL.

[![GitHub Repo stars](https://img.shields.io/badge/VILHALVA-GITHUB-03A9F4?logo=github)](https://github.com/VILHALVA) 
[![GitHub Repo stars](https://img.shields.io/badge/CURSO-COMPRETO-03A9F4?logo=youtube)](https://youtube.com/playlist?list=PLHz_AreHm4dmSj0MHol_aoNYCSGFqvfXV) <br>

[![GitHub Repo stars](https://img.shields.io/badge/VEJA%20DOCUMENTA√á√ÉO-PYTHON-03A9F4?logo=google)](https://docs.python.org/3/)
[![GitHub Repo stars](https://img.shields.io/badge/CONHE√áA%20PORTUGOL-STUDIO-03A9F4?logo=google)](http://lite.acad.univali.br/portugol/)

<img src="https://cdn-icons-png.flaticon.com/256/9670/9670741.png" align="center" width="250"> <br>

# üë®‚Äçüíª[TEM√ÅTICAS](https://youtube.com/playlist?list=PLHz_AreHm4dmSj0MHol_aoNYCSGFqvfXV)
* ‚úÖ [USANDO O SCRATCH](https://scratch.mit.edu/)
* ‚úÖ VARI√ÅVEIS SIMPLES
* ‚úÖ OPERADORES (ARITM√âTICOS, L√ìGICOS E RELACIONAIS)
* ‚úÖ ESTRUTURAS CONDICIONAIS
* ‚úÖ ESTRUTURA DE REPETI√á√ÉO FOR (PARA)
* ‚úÖ ESTRUTURA DE REPETI√á√ÉO WHILE (ENQUANTO)
* ‚úÖ PROCEDIMENTOS (FUN√á√ïES)
* ‚úÖ VETORES (VARIAVEIS COMPOSTAS 1)
* ‚úÖ MATRIZES (VARIAVEIS COMPOSTAS 2)

![](https://i.imgur.com/waxVImv.png)
# üìöSE APROFUDANDO MAIS:
## ( 0 ) OPERADORES:
Os operadores em linguagens de programa√ß√£o s√£o s√≠mbolos especiais ou palavras-chave que executam opera√ß√µes em valores ou vari√°veis. Eles permitem manipular e combinar dados para realizar c√°lculos, compara√ß√µes e outras opera√ß√µes. Aqui est√£o alguns dos operadores mais comuns encontrados em muitas linguagens de programa√ß√£o:

### ( 0.1 ) ARITM√âTICOS:

| SINAL | USADO |
| :---: | :---: |
| + | SOMA |
| - | SUBTRA√á√ÉO | 
| * | MULTIPLICA√á√ÉO | 
| / | DIVIS√ÉO | 
| % | M√ìDULO | 
| ++ | INCREMENTO | 
| -- | DECREMENTO | 

Os operadores aritm√©ticos na programa√ß√£o s√£o utilizados para realizar opera√ß√µes matem√°ticas em valores ou vari√°veis num√©ricas. Eles s√£o usados para adicionar, subtrair, multiplicar, dividir e realizar outras opera√ß√µes comuns em programa√ß√£o. Os operadores aritm√©ticos b√°sicos s√£o:

* **1. Soma (+):** Utilizada para adicionar dois valores ou vari√°veis. Exemplo: a + b.
* **2. Subtra√ß√£o (-):** Utilizada para subtrair um valor ou vari√°vel de outro. Exemplo: a - b.
* **3. Multiplica√ß√£o (*):** Utilizada para multiplicar dois valores ou vari√°veis. Exemplo: a * b.
* **4. Divis√£o (/):** Utilizada para dividir um valor ou vari√°vel por outro. Exemplo: a / b.
* **5. M√≥dulo (%):** Utilizada para calcular o resto da divis√£o inteira entre dois valores ou vari√°veis. Exemplo: a % b.

Al√©m dos operadores b√°sicos, tamb√©m temos os operadores de incremento e decremento:

* **1. Incremento (++):** Adiciona 1 ao valor ou vari√°vel. Exemplo: a++.
* **2. Decremento (--):** Subtrai 1 do valor ou vari√°vel. Exemplo: a--.

Tamb√©m √© importante lembrar que, em algumas linguagens de programa√ß√£o, a ordem de preced√™ncia dos operadores aritm√©ticos pode variar. Nesse caso, √© preciso lembrar da regra matem√°tica PEMDAS (ou PEDMAS), que define a ordem de prioridade das opera√ß√µes matem√°ticas: par√™nteses, exponencia√ß√£o, multiplica√ß√£o e divis√£o (da esquerda para a direita), e adi√ß√£o e subtra√ß√£o (da esquerda para a direita).

Por exemplo, na express√£o 2 + 3 * 4, a multiplica√ß√£o ser√° realizada antes da soma, resultando em 14. Para for√ßar a soma a ser realizada antes, deve-se usar par√™nteses: (2 + 3) * 4, resultando em 20.

Em resumo, os operadores aritm√©ticos s√£o importantes na programa√ß√£o e s√£o amplamente utilizados para realizar c√°lculos e outras opera√ß√µes matem√°ticas de forma eficiente e precisa.

### ( 0.2 ) RELACIONAIS:

| SINAL | USADO |
:---: | :---: |
| == | IGUAL |
| != | DIFERENTE |
| > | MAIOR QUE |
| < | MENOR QUE |
| >= | MAIOR OU IGUAL |
| <= | MENOR OU IGUAL |

Os operadores relacionais na programa√ß√£o s√£o utilizados para comparar valores e retornar um valor booleano (verdadeiro ou falso) como resultado. Eles s√£o amplamente utilizados em estruturas de controle de fluxo, que permitem executar diferentes trechos de c√≥digo de acordo com as condi√ß√µes especificadas. Os operadores relacionais comuns s√£o:

* **1. Igual (==):** Utilizado para comparar se dois valores ou vari√°veis s√£o iguais. Exemplo: a == b.
* **2. Diferente (!=):** Utilizado para comparar se dois valores ou vari√°veis s√£o diferentes. Exemplo: a != b.
* **3. Maior que (>):** Utilizado para comparar se um valor ou vari√°vel √© maior que outro. Exemplo: a > b.
* **4. Maior ou igual que (>=):** Utilizado para comparar se um valor ou vari√°vel √© maior ou igual a outro. Exemplo: a >= b.
* **5. Menor que (<):** Utilizado para comparar se um valor ou vari√°vel √© menor que outro. Exemplo: a < b.
* **6. Menor ou igual que (<=):** Utilizado para comparar se um valor ou vari√°vel √© menor ou igual a outro. Exemplo: a <= b.

O resultado de uma compara√ß√£o utilizando um operador relacional √© sempre um valor booleano, que pode ser verdadeiro (true) ou falso (false). Esse resultado pode ser usado como condi√ß√£o para estruturas de controle de fluxo, como o condicional "if" ou o loop "while".

√â importante lembrar que os operadores relacionais n√£o alteram os valores ou vari√°veis em quest√£o, apenas os comparam. Al√©m disso, alguns tipos de dados podem ser comparados com alguns operadores relacionais e outros n√£o. Por exemplo, √© poss√≠vel comparar dois n√∫meros inteiros utilizando todos os operadores relacionais, mas n√£o √© poss√≠vel comparar diretamente duas strings utilizando o operador maior que (>). Nesse caso, √© necess√°rio utilizar m√©todos especiais para realizar compara√ß√µes de strings.

Em resumo, os operadores relacionais s√£o importantes na programa√ß√£o e s√£o amplamente utilizados em estruturas de controle de fluxo para avaliar condi√ß√µes e tomar decis√µes com base nos resultados.

### ( 0.3 ) L√ìGICOS:

| ABREV | SIMBOLO | SIGNIFICADO | BOOLEANO |
:---: | :---: | :---: | :---:|
| AND | (&&) | E | TRUE TRUE |
| OR | (‚Äñ) | OU | TRUE FALSE |
| NOT | (!) | N√ÉO | FALSE FALSE |

Os operadores l√≥gicos s√£o usados na programa√ß√£o para combinar, comparar e modificar valores booleanos. Existem tr√™s operadores l√≥gicos principais:

* **1. AND (&&):** Retorna true se ambas as express√µes s√£o verdadeiras.
Exemplo:
````
if (a > 5 && b < 3) {
¬†¬† // c√≥digo a ser executado quando ambas as condi√ß√µes s√£o verdadeiras
}
````

* **2. OR (||):** Retorna true se pelo menos uma das express√µes √© verdadeira.
Exemplo:
````
if (a == 5 ‚Äñ b == 3) {
¬†¬† // c√≥digo a ser executado quando pelo menos uma das condi√ß√µes √© verdadeira
}
````

* **3. NOT (!):** Inverte o valor booleano, retornando true se a express√£o √© falsa e false se a express√£o √© verdadeira.
Exemplo:
````
if (!(a > 5)) {
¬†¬† // c√≥digo a ser executado quando a express√£o √© falsa
}
````
Os operadores l√≥gicos s√£o comumente usados junto com operadores relacionais (como <, >, <=, >=, ==, !=) para criar condi√ß√µes mais complexas que ajudam o programa a tomar decis√µes com base em v√°rias vari√°veis.

### ( 0.4 ) UN√ÅRIO:
Operador un√°rio √© um operador matem√°tico utilizado em programa√ß√£o que atua em apenas um operando, ao contr√°rio dos operadores bin√°rios, que atuam sobre dois operandos. Na programa√ß√£o, os operadores un√°rios s√£o usados para realizar opera√ß√µes em um √∫nico valor ou vari√°vel. Existem v√°rios tipos de operadores un√°rios, incluindo:

* **1. Operadores aritm√©ticos, que realizam opera√ß√µes matem√°ticas simples em um √∫nico valor ou vari√°vel, como incrementos/decrementos e nega√ß√£o:**

* ++: incremento. Adiciona 1 ao valor ou vari√°vel;
* --: decremento. Subtrai 1 do valor ou vari√°vel;
* +: positivo. N√£o faz nada, apenas mant√©m o sinal do valor ou vari√°vel;
* -: negativo. Inverte o sinal do valor ou vari√°vel.

* **2. Operadores l√≥gicos, que s√£o usados para avaliar valores booleanos:**

* !: nega√ß√£o l√≥gica. Inverte o valor booleano de true para false ou vice-versa.

* **3. Operadores de endere√ßo e ponteiro, que s√£o usados para acessar endere√ßos de mem√≥ria:**
* &: endere√ßo de. Retorna o endere√ßo de mem√≥ria de uma vari√°vel;
* *\: ponteiro. Retorna o valor armazenado no endere√ßo de mem√≥ria de uma vari√°vel.

* **4. Operadores de convers√£o de tipos, que convertem um valor de um tipo de dados para outro:**

* (tipo): convers√£o de tipo. Converte o valor ou vari√°vel para o tipo especificado.

Em resumo, os operadores un√°rios s√£o importantes em programa√ß√£o e s√£o amplamente utilizados em diferentes linguagens para realizar opera√ß√µes matem√°ticas, l√≥gicas, de endere√ßo, de conver√ß√£o de tipos e outras opera√ß√µes sobre um √∫nico valor ou vari√°vel.

### ( 0.5 ) BIN√ÅRIO:
Os operadores bit a bit permitem a manipula√ß√£o dos bits individuais de um valor. Eles s√£o aplicados em n√≠vel de bits e executam opera√ß√µes l√≥gicas nos bits individuais de dois valores. Aqui est√£o alguns exemplos de operadores bit a bit:

* **1. E bit a bit (&):** Realiza uma opera√ß√£o "E" bit a bit entre dois valores. Cada bit correspondente nos dois valores √© comparado e o resultado cont√©m um 1 apenas se ambos os bits forem 1. Caso contr√°rio, o resultado cont√©m 0. Por exemplo:
   ```
   int a = 5;  // 0101 em bin√°rio
   int b = 3;  // 0011 em bin√°rio
   int resultado = a & b; // resultado = 1 (0001 em bin√°rio)
   ```

* **2. Ou bit a bit (|):** Realiza uma opera√ß√£o "OU" bit a bit entre dois valores. Cada bit correspondente nos dois valores √© comparado e o resultado cont√©m um 1 se pelo menos um dos bits for 1. Caso contr√°rio, o resultado cont√©m 0. Por exemplo:
   ```
   int a = 5;  // 0101 em bin√°rio
   int b = 3;  // 0011 em bin√°rio
   int resultado = a | b; // resultado = 7 (0111 em bin√°rio)
   ```

* **3. Deslocamento √† esquerda (<<):** Desloca os bits de um valor para a esquerda, preenchendo os bits √† direita com zeros. Cada deslocamento para a esquerda dobra o valor original. Por exemplo:
   ```
   int a = 5; // 0101 em bin√°rio
   int resultado = a << 2; // resultado = 20 (10100 em bin√°rio)
   ```

* 4. **Deslocamento √† direita (>>):** Desloca os bits de um valor para a direita, descartando os bits √† direita. O sinal do valor original √© preservado para n√∫meros com sinal (aritm√©tica √† direita) e os bits mais significativos s√£o preenchidos com o bit de sinal para n√∫meros com sinal. Por exemplo:
   ```
   int a = 10; // 1010 em bin√°rio
   int resultado = a >> 2; // resultado = 2 (0010 em bin√°rio)
   ```

Na verdade, os operadores bit a bit s√£o operadores bin√°rios, pois eles operam nos bits individuais dos valores em uma representa√ß√£o bin√°ria. Esses operadores realizam opera√ß√µes l√≥gicas bit a bit nos valores fornecidos. Portanto, eles s√£o chamados de operadores bin√°rios, j√° que trabalham com a representa√ß√£o bin√°ria dos valores em um n√≠vel de bits. Esses s√£o apenas alguns exemplos de operadores bit a bit dispon√≠veis em muitas linguagens de programa√ß√£o. Eles s√£o √∫teis em situa√ß√µes em que √© necess√°rio manipular valores em n√≠vel de bits ou realizar opera√ß√µes de baixo n√≠vel. √â importante ressaltar que o uso desses operadores pode variar dependendo da linguagem de programa√ß√£o espec√≠fica.

### ( 0.6 ) TERN√ÅRIO:
Operador tern√°rio √© um operador condicional presente em algumas linguagens de programa√ß√£o, como C, C++, Java, Python, entre outras. Ele √© geralmente utilizado em situa√ß√µes que envolvem questionamentos condicionais, onde o resultado pode ser um ou outro valor.
A sintaxe do operador tern√°rio √© tipicamente:

````
(condi√ß√£o) ? valor_se_verdadeiro : valor_se_falso;
````

Onde:
* Condi√ß√£o: √© a express√£o que ser√° avaliada como verdadeira ou falsa;
* Valorseverdadeiro: √© o valor que ser√° retornado se a condi√ß√£o for verdadeira;
* Valorsefalso: √© o valor que ser√° retornado se a condi√ß√£o for falsa.

O operador tern√°rio √© uma forma condensada de escrever um c√≥digo que seria feito com a estrutura de if-else. Ao inv√©s de escrever um bloco de condi√ß√µes if-else, voc√™ pode usar o operador tern√°rio para executar a opera√ß√£o de acordo com o valor true ou false resultante da condi√ß√£o.
Um exemplo de uso do operador tern√°rio √©:
````
int a = 10;
String mensagem = (a > 5) ? "O valor de a √© maior que 5" : "O valor de a √© menor que 5";
System.out.println(mensagem);
````
Nesse exemplo, a vari√°vel a recebe o valor 10. A condi√ß√£o (a > 5) √© avaliada como true, ent√£o a vari√°vel mensagem recebe o valor "O valor de a √© maior que 5". Caso a condi√ß√£o fosse avaliada como false, a vari√°vel mensagem receberia o valor "O valor de a √© menor que 5". O operador tern√°rio √© uma ferramenta √∫til para simplificar o c√≥digo e torn√°-lo mais leg√≠vel e conciso, mas √© importante us√°-lo com modera√ß√£o e de forma adequada, para n√£o comprometer a facilidade de entendimento do c√≥digo.

## ( 1 ) VARI√ÅVEIS SIMPLES:
As vari√°veis simples s√£o vari√°veis que armazenam um √∫nico valor em um determinado momento. Esses tipos de vari√°veis armazenam valores de tipos de dados b√°sicos, como inteiros, reais, caracteres, booleanos, entre outros, dependendo da linguagem de programa√ß√£o.
Por exemplo, uma vari√°vel "int x" pode armazenar um √∫nico valor do tipo inteiro em um determinado momento. Outra vari√°vel "float y" pode armazenar um valor real de ponto flutuante.
As vari√°veis simples s√£o essenciais para a programa√ß√£o e s√£o usadas amplamente em todos os tipos de algoritmos e opera√ß√µes. Elas s√£o frequentemente utilizadas para armazenar valores de entrada do usu√°rio, resultados de c√°lculos, contadores de loops e √≠ndices de matrizes ou arrays.
Ao contr√°rio das vari√°veis compostas, uma vari√°vel simples n√£o pode armazenar conjuntos inteiros de valores relacionados de maneira eficiente. Se voc√™ precisar armazenar muitos valores relacionados, seria necess√°rio criar v√°rias vari√°veis simples distintas para armazen√°-los. Por exemplo, se voc√™ quiser armazenar o nome, sobrenome, endere√ßo e idade de uma pessoa, seria necess√°rio criar quatro vari√°veis simples um para cada atributo. Exemplo:
````
// Exemplo de vari√°veis simples em Java
public class ExemploVariaveis {
    public static void main(String[] args) {
        // Declara√ß√£o e atribui√ß√£o de vari√°veis
        int idade = 25;
        double altura = 1.75;
        char genero = 'M';
        boolean ehEstudante = true;
        String nome = "Jo√£o";

        // Utiliza√ß√£o das vari√°veis
        System.out.println("Nome: " + nome);
        System.out.println("Idade: " + idade);
        System.out.println("Altura: " + altura);
        System.out.println("G√™nero: " + genero);
        System.out.println("√â estudante? " + ehEstudante);
    }
}
````

## ( 2 ) ESTRUTURA CONDICIONAL:
As estruturas condicionais s√£o um recurso da programa√ß√£o que permitem a execu√ß√£o de um bloco de c√≥digo baseado em uma condi√ß√£o. Basicamente, a estrutura condicional verifica se uma determinada condi√ß√£o √© verdadeira ou falsa e executa o c√≥digo correspondente.
A estrutura condicional consiste em tr√™s partes principais: a condi√ß√£o, o bloco de c√≥digo que ser√° executado se a condi√ß√£o for verdadeira (bloco "ent√£o"), e o bloco de c√≥digo que ser√° executado se a condi√ß√£o for falsa (bloco "sen√£o").

### ( 2.1 ) IF-ELSE:
As duas principais estruturas condicionais s√£o a "if-else" e a "switch-case". Na estrutura "if-else", o c√≥digo dentro do bloco "ent√£o" √© executado somente se a condi√ß√£o for verdadeira. Caso contr√°rio, o c√≥digo dentro do bloco "sen√£o" ser√° executado, se houver um bloque "sen√£o". Exemplo:
````
if (idade >= 18) {
¬†¬† System.out.println("Pode votar!");
} 
else {
¬†¬† System.out.println("Ainda √© jovem para votar.");
}
````
### ( 2.2 ) CONDICIONAL ANINHADA:
Uma estrutura condicional aninhada √© quando temos uma estrutura condicional dentro de outra estrutura condicional. Aqui est√° um exemplo em Java:
```
int idade = 25;
boolean temCarteiraMotorista = true;

if (idade >= 18) {
    System.out.println("Voc√™ √© maior de idade.");

    if (temCarteiraMotorista) {
        System.out.println("E voc√™ possui carteira de motorista.");
    } 
    else {
        System.out.println("Mas voc√™ n√£o possui carteira de motorista.");
    }
} 
else {
    System.out.println("Voc√™ √© menor de idade.");
}
```
Neste exemplo, temos uma estrutura condicional `if` aninhada dentro de outra estrutura condicional `if`. A primeira condi√ß√£o verifica se a idade √© maior ou igual a 18. Se for verdadeira, imprime "Voc√™ √© maior de idade" e ent√£o verifica se a pessoa possui carteira de motorista. Se a pessoa tiver carteira, imprime "E voc√™ possui carteira de motorista", caso contr√°rio, imprime "Mas voc√™ n√£o possui carteira de motorista". Se a primeira condi√ß√£o n√£o for verdadeira, ou seja, se a idade for menor que 18, imprime "Voc√™ √© menor de idade". As estruturas condicionais aninhadas s√£o √∫teis quando precisamos avaliar m√∫ltiplas condi√ß√µes de forma hier√°rquica e tomar diferentes a√ß√µes com base nesses resultados.

### ( 2.3 ) O SWITCH-CASE:
Na estrutura "switch-case", o c√≥digo selecionado para execu√ß√£o depende do valor de uma vari√°vel. √â poss√≠vel ter v√°rios casos no bloco "caso", onde cada caso representa um valor diferente da vari√°vel. Exemplo:
````
switch (nota) {
¬†¬† case 10:
¬†¬†¬†¬†¬† System.out.println("Nota m√°xima!");
¬†¬†¬†¬†¬† break;
¬†¬† case 7:
¬†¬†¬†¬†¬† System.out.println("Aprovado.");
¬†¬†¬†¬†¬† break;
¬†¬† default:
¬†¬†¬†¬†¬† System.out.println("Reprovado.");
}
````
Com essas estruturas condicionais, os programadores podem controlar o fluxo do programa de maneira muito mais eficiente, garantindo que cada bloco de c√≥digo seja executado apenas quando necess√°rio.

## ( 3 ) ESTRUTURA DE REPETI√á√ÉO:
As estruturas de repeti√ß√£o, tamb√©m conhecidas como la√ßos ou loops, s√£o utilizadas em programa√ß√£o para executar um conjunto de instru√ß√µes repetidamente, enquanto uma condi√ß√£o espec√≠fica √© satisfeita. Existem tr√™s principais tipos de loops em programa√ß√£o:

### ( 3.1 ) O LOOP WHILE:
O while √© utilizado quando n√£o se sabe o n√∫mero exato de vezes que as instru√ß√µes devem ser repetidas. A condi√ß√£o √© testada antes de cada itera√ß√£o do loop, e enquanto a condi√ß√£o permanecer verdadeira, o loop ir√° executar as instru√ß√µes. A estrutura do loop while √© a seguinte:
````
while (condicao) {
¬† // instrucoes
}
````

### ( 3.2 ) O LOOP DO-WHILE:
O do-while √© similar ao loop while, mas a condi√ß√£o √© testada depois de cada itera√ß√£o do loop. Isso significa que, independente da condi√ß√£o, o loop ir√° executar as instru√ß√µes pelo menos uma vez. A estrutura do loop do-while √© a seguinte:
````
do {
¬† // instrucoes
} while (condicao);
````

### ( 3.2 ) O LOOP FOR:
O loop for √© utilizado quando se sabe o n√∫mero exato de vezes que o loop deve ser executado. Ele √© composto por tr√™s partes: a inicializa√ß√£o, a condi√ß√£o e a atualiza√ß√£o. A inicializa√ß√£o √© executada apenas uma vez, no in√≠cio do loop. A condi√ß√£o √© testada antes de cada itera√ß√£o do loop e, enquanto a condi√ß√£o permanecer verdadeira, o loop ir√° executar as instru√ß√µes. A atualiza√ß√£o √© executada no final de cada itera√ß√£o do loop. A estrutura do loop for √© a seguinte:
````
for (inicializacao; condicao; atualizacao) {
¬† // instrucoes
}
````
Cada uma dessas estruturas pode ser utilizada para diferentes prop√≥sitos, dependendo da l√≥gica do programa. A escolha da estrutura ideal depende do problema a ser resolvido e da l√≥gica do programa em si. √â importante lembrar que loops mal escritos podem causar problemas como loops infinitos e travamentos do programa, ent√£o √© importante ter cuidado ao implement√°-los.

## ( 4 ) VARI√ÅVEIS COMPOSTAS:
Vari√°veis compostas na programa√ß√£o s√£o tipos de dados que podem armazenar um conjunto de valores relacionados como se fossem um √∫nico valor. Esses tipos incluem arrays, listas, matrizes, tuplas, dicion√°rios, entre outros, dependendo da linguagem de programa√ß√£o utilizada.

### ( 4.1 ) ARRAY: 
√â uma vari√°vel composta que pode armazenar uma sequ√™ncia de valores do mesmo tipo em uma √∫nica vari√°vel. Cada valor no array pode ser acessado por seu √≠ndice, que come√ßa em 0.
````
// Exemplo de array em Java
public class ExemploArray {
    public static void main(String[] args) {
        // Declara√ß√£o e inicializa√ß√£o de um array de inteiros
        int[] numeros = {1, 2, 3, 4, 5};

        // Acessando elementos do array
        System.out.println(numeros[0]);  // Sa√≠da: 1
        System.out.println(numeros[2]);  // Sa√≠da: 3

        // Modificando um elemento do array
        numeros[0] = 10;
        System.out.println(numeros[0]);  // Sa√≠da: 10

        // Percorrendo o array com um loop for
        for (int i = 0; i < numeros.length; i++) {
            System.out.println(numeros[i]);
        }
    }
}
````

### ( 4.2 ) LISTA:
√â uma vari√°vel composta que pode armazenar uma sequ√™ncia de valores arbitr√°rios de diferentes tipos de dados. Os itens na lista tamb√©m podem ser acessados por seus √≠ndices n√∫mericos, assim como em um array.
````
import java.util.ArrayList;

// Exemplo de ArrayList em Java
public class ExemploArrayList {
    public static void main(String[] args) {
        // Declara√ß√£o e inicializa√ß√£o de um ArrayList de Strings
        ArrayList<String> nomes = new ArrayList<>();

        // Adicionando elementos ao ArrayList
        nomes.add("Jo√£o");
        nomes.add("Maria");
        nomes.add("Pedro");

        // Acessando elementos do ArrayList
        System.out.println(nomes.get(0));  // Sa√≠da: "Jo√£o"
        System.out.println(nomes.get(2));  // Sa√≠da: "Pedro"

        // Modificando um elemento do ArrayList
        nomes.set(0, "Lucas");
        System.out.println(nomes.get(0));  // Sa√≠da: "Lucas"

        // Percorrendo o ArrayList com um loop for-each
        for (String nome : nomes) {
            System.out.println(nome);
        }
    }
}
````

### ( 4.3 ) DICION√ÅRIOS:
S√£o vari√°veis compostas mais complexas que armazenam valores em pares chave-valor, permitindo que os valores sejam acessados por sua chave, em vez de um √≠ndice. 
````
// Exemplo de dicion√°rio em JavaScript
let dicionario = {
    "Ma√ß√£": 10,
    "Laranja": 5,
    "Banana": 7
};

// Acessando elementos do dicion√°rio
console.log(dicionario["Ma√ß√£"]);     // Sa√≠da: 10
console.log(dicionario["Laranja"]);  // Sa√≠da: 5

// Modificando um elemento do dicion√°rio
dicionario["Banana"] = 15;
console.log(dicionario["Banana"]);   // Sa√≠da: 15

// Percorrendo o dicion√°rio com um loop for-in
for (let chave in dicionario) {
    console.log(chave + ": " + dicionario[chave]);
}
````

### ( 4.4 ) MATRIZES:
S√£o semelhantes √†s arrays, mas permitem armazenar valores em uma ou mais dimens√µes. As tuplas s√£o semelhantes √†s listas, mas s√£o imut√°veis, o que significa que n√£o podem ser alteradas depois de criadas.
````
// Exemplo de matriz em Java
public class ExemploMatriz {
    public static void main(String[] args) {
        // Declara√ß√£o e inicializa√ß√£o de uma matriz de inteiros
        int[][] matriz = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };

        // Acessando elementos da matriz
        System.out.println(matriz[0][0]);  // Sa√≠da: 1
        System.out.println(matriz[1][2]);  // Sa√≠da: 6

        // Modificando um elemento da matriz
        matriz[2][1] = 10;
        System.out.println(matriz[2][1]);  // Sa√≠da: 10

        // Percorrendo a matriz com loops aninhados
        for (int i = 0; i < matriz.length; i++) {
            for (int j = 0; j < matriz[i].length; j++) {
                System.out.print(matriz[i][j] + " ");
            }
            System.out.println();
        }
    }
}
````
Usando vari√°veis compostas, os programadores podem armazenar e manipular conjuntos de dados relacionados de forma mais eficiente e conveniente do que armazenar cada valor em uma vari√°vel separada.

## ( 5 ) FUN√á√ïES OU METODOS:
* Uma fun√ß√£o √© uma por√ß√£o de c√≥digo que realiza uma tarefa espec√≠fica e pode ser chamada, ou invocada, em diferentes partes do programa. A fun√ß√£o geralmente recebe um ou mais argumentos como entrada, executa uma s√©rie de opera√ß√µes em cima deles e pode retornar um valor de sa√≠da para o restante do programa.
As fun√ß√µes permitem que os programadores escrevam c√≥digo mais modular e reutiliz√°vel. Ao inv√©s de repetir o mesmo bloco de c√≥digo em v√°rias partes do programa, uma √∫nica fun√ß√£o pode ser criada para realizar essa tarefa e chamada sempre que necess√°rio.
As fun√ß√µes podem ser criadas em quase todas as linguagens de programa√ß√£o. Em linguagens orientadas a objetos, as fun√ß√µes s√£o frequentemente chamadas de m√©todos. As fun√ß√µes podem ser criadas como parte de uma classe ou como fun√ß√µes independentes.
Por exemplo, vamos examinar o seguinte trecho de c√≥digo em Python que ilustra uma fun√ß√£o simples que soma dois n√∫meros e retorna o resultado:
````
// C√ìDIGO EM PYTHON:
def soma(a, b): // Definindo uma fun√ß√£o.
¬†¬† resultado = a + b
¬†¬† return resultado
   
v1 = soma(4,8) // Chamando a fun√ß√£o soma com os valores 4,8 (=12).
print(v1)
````
Neste exemplo de c√≥digo, a fun√ß√£o "soma" √© criada com dois argumentos, "a" e "b", que ser√£o usados para realizar a opera√ß√£o matem√°tica. Dentro da fun√ß√£o, a opera√ß√£o √© realizada e o resultado √© armazenado na vari√°vel "resultado". A fun√ß√£o retorna o valor de "resultado" para o c√≥digo que a chamou.
````
// Definindo uma fun√ß√£o que retorna o dobro de um n√∫mero em JavaScript
function dobrarNumero(numero) {
    return numero * 2;
}

// Chamando a fun√ß√£o e armazenando o resultado em uma vari√°vel
var resultado = dobrarNumero(5);
console.log(resultado);  // Sa√≠da: 10
````
Neste exemplo, temos uma fun√ß√£o chamada dobrarNumero que recebe um par√¢metro chamado numero. Dentro da fun√ß√£o, multiplicamos o n√∫mero por 2 e retornamos o resultado usando a palavra-chave return.
Em seguida, chamamos a fun√ß√£o dobrarNumero passando o valor 5 como argumento. O resultado retornado pela fun√ß√£o √© armazenado na vari√°vel resultado e, em seguida, imprimimos o valor de resultado no console.
Esses s√£o apenas exemplos simples de fun√ß√µes em JavaScript. As fun√ß√µes em JavaScript s√£o bastante flex√≠veis e podem ser usadas para executar tarefas complexas, manipular dados, interagir com o ambiente do navegador e muito mais.
As fun√ß√µes podem ser uma √≥tima maneira de tornar o c√≥digo mais f√°cil de ler e manter, ao mesmo tempo que aumentam a modularidade e a reutiliza√ß√£o do c√≥digo.

## ( 6 ) CLASS POO:
A programa√ß√£o orientada a objetos (POO) √© uma abordagem de programa√ß√£o que se baseia no conceito de objetos, que podem conter dados e fun√ß√µes e interagir com outros objetos.
Em POO, os objetos s√£o criados a partir de classes que servem como modelos para definir seus atributos (dados) e m√©todos (fun√ß√µes). Cada objeto, por sua vez, pode ter seu pr√≥prio conjunto de valores de dados exclusivo, mesmo que compartilhe a mesma classe. Al√©m disso, os objetos podem se comunicar com outros objetos atrav√©s de mecanismos de troca de mensagem.
Os quatro pilares da POO s√£o encapsulamento, heran√ßa, polimorfismo e abstra√ß√£o. O encapsulamento √© o princ√≠pio de manter o comportamento interno e a estrutura de um objeto ocultos ao mundo externo e ao c√≥digo que √© escrito fora da classe. A heran√ßa √© o processo de criar uma nova classe baseada em uma classe existente - a nova classe herda os atributos e m√©todos da classe pai. O polimorfismo √© a capacidade de um objeto se comportar de v√°rias maneiras diferentes. E a abstra√ß√£o √© a capacidade de omitir informa√ß√µes detalhadas e irrelevantes e concentrar-se apenas nos aspectos importantes do objeto.
As linguagens de programa√ß√£o orientadas a objetos comuns incluem Java, Python, Ruby, C++ e C#. A maioria dessas linguagens permite a defini√ß√£o de novas classes, bem como a reutiliza√ß√£o de classes existentes atrav√©s da heran√ßa. A programa√ß√£o orientada a objetos √© amplamente utilizada na programa√ß√£o de aplicativos de desktop, jogos, aplicativos para dispositivos m√≥veis, aplicativos web e em muitos outros tipos de software.
A programa√ß√£o orientada a objetos √© uma poderosa abordagem de programa√ß√£o que permite a cria√ß√£o de c√≥digo mais modular e f√°cil de manter. Ela incentiva uma programa√ß√£o mais organizada, promove a reutiliza√ß√£o de c√≥digo e enfatiza a import√¢ncia da clareza e da estrutura√ß√£o do c√≥digo. Exemplo:
````
// Exemplo de classe em Java
public class Pessoa {
    // Vari√°veis de inst√¢ncia
    private String nome;
    private int idade;
    
    // Construtor da classe
    public Pessoa(String nome, int idade) {
        this.nome = nome;
        this.idade = idade;
    }
    
    // M√©todos de inst√¢ncia
    public String getNome() {
        return nome;
    }
    
    public int getIdade() {
        return idade;
    }
    
    public void fazerAniversario() {
        idade++;
    }
    
    // M√©todo main para teste
    public static void main(String[] args) {
        // Criando uma inst√¢ncia da classe Pessoa
        Pessoa pessoa = new Pessoa("Jo√£o", 25);
        
        // Utilizando os m√©todos da inst√¢ncia
        System.out.println("Nome: " + pessoa.getNome());
        System.out.println("Idade: " + pessoa.getIdade());
        
        pessoa.fazerAniversario();
        
        System.out.println("Idade ap√≥s anivers√°rio: " + pessoa.getIdade());
    }
}
````

### ( 6.1 ) OS QUATRO PILARES:
Os quatro pilares da programa√ß√£o orientada a objetos s√£o:

#### ( 6.1.1 ) ABSTRA√á√ÉO:
√â a capacidade de omitir informa√ß√µes detalhadas e irrelevantes e concentrar-se apenas nos aspectos importantes do objeto.

##### ( 6.1.1.1 ) OBJETIVO:
O objetivo da abstra√ß√£o √© estabelecer uma forma mais simples e gen√©rica de se pensar nos objetos. Isso √© feito identificando os aspectos mais importantes de um objeto e modelando-o em uma classe. A abstra√ß√£o pode ser alcan√ßada por meio de classes abstratas e interfaces, que permitem a especifica√ß√£o dos m√©todos e atributos que uma classe deve implementar sem fornecer uma implementa√ß√£o real.
````
// Classe abstrata
abstract class Animal {
    private String nome;
    
    public Animal(String nome) {
        this.nome = nome;
    }
    
    // M√©todo abstrato
    public abstract void emitirSom();
    
    // M√©todo concreto
    public void dormir() {
        System.out.println("O animal est√° dormindo.");
    }
    
    // Getter para o nome
    public String getNome() {
        return nome;
    }
}

// Classe concreta
class Cachorro extends Animal {
    public Cachorro(String nome) {
        super(nome);
    }
    
    public void emitirSom() {
        System.out.println("O cachorro est√° latindo.");
    }
}

// Exemplo de abstra√ß√£o em Java
public class ExemploAbstracao {
    public static void main(String[] args) {
        Cachorro cachorro = new Cachorro("Rex");
        
        System.out.println("Nome do cachorro: " + cachorro.getNome());
        cachorro.emitirSom();  // Sa√≠da: O cachorro est√° latindo.
        cachorro.dormir();     // Sa√≠da: O animal est√° dormindo.
    }
}
````
Neste exemplo, temos uma classe abstrata chamada Animal, que cont√©m um m√©todo abstrato emitirSom(). Essa classe abstrata tamb√©m possui um m√©todo concreto dormir() e um atributo nome.
A classe concreta Cachorro estende a classe abstrata Animal e implementa o m√©todo abstrato emitirSom() de acordo com o comportamento espec√≠fico do cachorro.
No m√©todo main, criamos uma inst√¢ncia da classe Cachorro chamada cachorro. Podemos chamar o m√©todo emitirSom() e o m√©todo dormir() da classe Animal usando essa inst√¢ncia.
A classe abstrata Animal serve como um modelo gen√©rico para representar animais e define a estrutura b√°sica comum para todas as classes derivadas. As classes concretas, como Cachorro, implementam os detalhes espec√≠ficos do comportamento.

A abstra√ß√£o nos permite representar conceitos gen√©ricos e definir comportamentos comuns em classes abstratas, enquanto as classes concretas fornecem a implementa√ß√£o espec√≠fica desses comportamentos. A abstra√ß√£o nos ajuda a criar um c√≥digo mais flex√≠vel, reutiliz√°vel e de f√°cil manuten√ß√£o.
As classes abstratas s√£o utilizadas como base para outras classes, servindo como modelos ou blueprints para a cria√ß√£o de objetos mais espec√≠ficos. Elas cont√™m m√©todos abstratos, que s√£o m√©todos sem implementa√ß√£o definida na classe abstrata, e tamb√©m podem conter m√©todos concretos com implementa√ß√£o.

Uma classe abstrata n√£o pode ser instanciada diretamente porque ela √© considerada incompleta. Ou seja, ela possui m√©todos abstratos que n√£o possuem uma implementa√ß√£o definida na classe abstrata. Dessa forma, criar um objeto a partir de uma classe abstrata seria problem√°tico, j√° que n√£o ter√≠amos uma implementa√ß√£o completa para todos os m√©todos necess√°rios.

No entanto, as classes abstratas podem ser herdadas por outras classes, permitindo que essas classes filhas forne√ßam uma implementa√ß√£o concreta para os m√©todos abstratos. Essas classes filhas devem implementar todos os m√©todos abstratos herdados da classe abstrata, tornando-as instanci√°veis.
A ideia por tr√°s das classes abstratas √© fornecer uma estrutura comum e definir um contrato para as classes derivadas. Elas s√£o projetadas para serem estendidas e especializadas por meio da heran√ßa, permitindo a cria√ß√£o de objetos mais espec√≠ficos e completos. Ao impedir a instancia√ß√£o direta das classes abstratas, garantimos que todas as subclasses sigam o contrato definido pela classe abstrata e forne√ßam as implementa√ß√µes necess√°rias para todos os m√©todos abstratos.

##### ( 6.1.1.2 ) O QUE √â INTERFACE?:
A interface √© um elemento fundamental na programa√ß√£o orientada a objetos (POO) e faz parte do pilar da Abstra√ß√£o. Ela permite definir um contrato ou um conjunto de m√©todos que uma classe deve implementar. Em outras palavras, uma interface estabelece um conjunto de funcionalidades que uma classe concreta deve ter.

Ao utilizar interfaces, podemos estabelecer um contrato comum entre diferentes classes, permitindo que elas sejam intercambi√°veis em determinados contextos. Isso promove a flexibilidade, modularidade e reutiliza√ß√£o de c√≥digo.

Em Java, por exemplo, podemos criar uma interface chamada `Veiculo` que define m√©todos como `acelerar()`, `frear()` e `obterVelocidade()`. Em seguida, podemos implementar essa interface em classes como `Carro`, `Moto` e `Caminhao`. Todas essas classes devem implementar os m√©todos definidos na interface `Veiculo`, mas cada uma delas pode ter sua pr√≥pria implementa√ß√£o.
Exemplo de declara√ß√£o de uma interface em Java:
```
public interface Veiculo {
    void acelerar();
    void frear();
    int obterVelocidade();
}
```
Exemplo de implementa√ß√£o da interface em uma classe concreta:

```
public class Carro implements Veiculo {
    private int velocidade;

    public void acelerar() {
        // Implementa√ß√£o espec√≠fica para acelerar um carro
    }

    public void frear() {
        // Implementa√ß√£o espec√≠fica para frear um carro
    }

    public int obterVelocidade() {
        // Implementa√ß√£o para obter a velocidade de um carro
        return velocidade;
    }
}
```
No exemplo acima, a classe `Carro` implementa a interface `Veiculo` e fornece sua pr√≥pria implementa√ß√£o para os m√©todos `acelerar()`, `frear()` e `obterVelocidade()`. Essa implementa√ß√£o √© espec√≠fica para um carro, mas outras classes que implementem a interface `Veiculo` devem fornecer suas pr√≥prias implementa√ß√µes para esses m√©todos.

#### ( 6.1.2 ) ENCAPSULAMENTO: 
√â o princ√≠pio de manter o comportamento interno e a estrutura de um objeto ocultos ao mundo externo e ao c√≥digo que √© escrito fora da classe. O objetivo desse pilar √© esconder a complexidade dos objetos e proteger o seu estado interno de manipula√ß√µes indevidas. Isso √© feito definindo-se n√≠veis de acesso aos m√©todos e √†s vari√°veis de uma classe, como p√∫blico, privado ou protegido.
````
// Exemplo de encapsulamento em Java
public class Pessoa {
    private String nome;
    private int idade;
    
    // M√©todo getter para o nome
    public String getNome() {
        return nome;
    }
    
    // M√©todo setter para o nome
    public void setNome(String nome) {
        this.nome = nome;
    }
    
    // M√©todo getter para a idade
    public int getIdade() {
        return idade;
    }
    
    // M√©todo setter para a idade
    public void setIdade(int idade) {
        this.idade = idade;
    }
    
    // M√©todo main para teste
    public static void main(String[] args) {
        Pessoa pessoa = new Pessoa();
        
        // Usando os m√©todos getter e setter
        pessoa.setNome("Jo√£o");
        pessoa.setIdade(25);
        
        System.out.println("Nome: " + pessoa.getNome());
        System.out.println("Idade: " + pessoa.getIdade());
    }
}
````
Neste exemplo, a classe Pessoa possui duas vari√°veis de inst√¢ncia nome e idade, que s√£o marcadas como private. Isso significa que essas vari√°veis s√≥ podem ser acessadas dentro da pr√≥pria classe.
Em seguida, a classe fornece m√©todos getter e setter para acessar e modificar essas vari√°veis. Os m√©todos getter permitem obter o valor das vari√°veis, enquanto os m√©todos setter permitem definir novos valores para as vari√°veis.
Dentro do m√©todo main, criamos uma inst√¢ncia da classe Pessoa e utilizamos os m√©todos setter para atribuir valores ao nome e √† idade da pessoa. Em seguida, utilizamos os m√©todos getter para obter os valores e exibimos na sa√≠da do console.

* **( 6.1.2.1 ) PUBLIC:** Os membros declarados como public s√£o acess√≠veis de qualquer lugar, tanto dentro da classe quanto fora dela. Eles podem ser acessados diretamente pelos objetos da classe ou por outras classes. Por exemplo:
````
public class Exemplo {
    public int valorPublico;
    
    public void metodoPublico() {
        // c√≥digo aqui
    }
}
````

* **( 6.1.2.2 ) PRIVATE:** Os membros declarados como private s√£o acess√≠veis apenas dentro da pr√≥pria classe. Eles n√£o podem ser acessados diretamente por objetos de outras classes. Essa visibilidade √© √∫til para proteger os detalhes internos da implementa√ß√£o de uma classe. Por exemplo:
````
public class Exemplo {
    private int valorPrivado;
    
    private void metodoPrivado() {
        // c√≥digo aqui
    }
}
````

* **( 6.1.2.3 ) PROTECTED:** Os membros declarados como protected s√£o acess√≠veis dentro da classe em que foram definidos, al√©m de serem acess√≠veis nas subclasses dessa classe. Ou seja, eles t√™m uma visibilidade um pouco mais ampla do que private, permitindo o acesso por subclasses. No entanto, eles n√£o s√£o acess√≠veis a partir de outras classes fora da hierarquia de heran√ßa. Por exemplo:
````
public class Exemplo {
    protected int valorProtegido;
    
    protected void metodoProtegido() {
        // c√≥digo aqui
    }
}
````

Ao utilizar o encapsulamento, estamos protegendo os detalhes internos da classe e permitindo um acesso controlado aos seus membros. Isso ajuda a manter a integridade dos dados e facilita a manuten√ß√£o do c√≥digo, permitindo uma maior flexibilidade na implementa√ß√£o interna da classe.
A escolha do modificador de acesso a ser utilizado depende da necessidade de cada membro em rela√ß√£o √† sua visibilidade. O uso adequado desses modificadores pode garantir a seguran√ßa e a consist√™ncia do c√≥digo, ao mesmo tempo em que permite um acoplamento adequado entre as classes.
√â importante ressaltar que essas defini√ß√µes de modificadores de acesso podem variar entre as linguagens de programa√ß√£o, mas os conceitos b√°sicos de encapsulamento e controle de acesso s√£o amplamente aplicados em muitas linguagens orientadas a objetos.

* **( 6.1.2.4 ) OS M√âTODOS GETTERS, SETTERS E CONSTRUTOR:**
* Os m√©todos getters e setters s√£o utilizados em programa√ß√£o orientada a objetos para acessar e modificar os atributos de um objeto de classe. Os getters, ou acessores, s√£o m√©todos que retornam o valor de um atributo enquanto os setters, ou modificadores, s√£o m√©todos que definem o valor de um atributo. Eles s√£o importantes para manter a privacidade e a seguran√ßa dos dados de uma classe, garantindo que o acesso aos atributos seja controlado.

* **‚õîGETTERS:** Os m√©todos getters s√£o utilizados para obter o valor de um atributo, fornecendo acesso somente leitura. Esses m√©todos geralmente t√™m o prefixo "get" seguido pelo nome do atributo e n√£o recebem par√¢metros. Eles retornam o valor do atributo desejado. 
Por exemplo, suponha que eu tenha uma classe chamada "Pessoa" que tem um atributo "idade". O m√©todo getter para o atributo idade seria escrito como:
````
public int getIdade() {
¬† return idade;
}
````

* **‚õîSETTERS:** Os m√©todos setters s√£o utilizados para definir o valor de um atributo, fornecendo acesso somente escrita. Esses m√©todos geralmente t√™m o prefixo "set" seguido pelo nome do atributo e recebem um par√¢metro correspondente ao novo valor do atributo. 
O m√©todo setter seria escrito da seguinte forma:
````
public void setIdade(int novaIdade) {
¬† idade = novaIdade;
}
````

* **‚õîCONSTRUTOR:** Os construtores s√£o m√©todos especiais usados para criar e inicializar objetos de uma classe. Eles t√™m o mesmo nome da classe e podem receber par√¢metros para definir os valores iniciais dos atributos do objeto. Os construtores s√£o chamados no momento da cria√ß√£o do objeto e permitem a configura√ß√£o inicial do seu estado.
Por exemplo, o construtor da classe Pessoa pode ser escrito assim:
````
public Pessoa(String nome, int idade) {
¬† this.nome = nome;
¬† this.idade = idade;
}
````

Neste caso, o construtor recebe dois argumentos (o nome e a idade da pessoa) e inicializa os atributos correspondentes. O "this" √© utilizado para referenciar o objeto atual que est√° sendo criado.
````
public class Pessoa {
    private String nome;
    private int idade;
    
    // Construtor
    public Pessoa(String nome, int idade) {
        this.nome = nome;
        this.idade = idade;
    }
    
    // Getter para o nome
    public String getNome() {
        return nome;
    }
    
    // Setter para o nome
    public void setNome(String nome) {
        this.nome = nome;
    }
    
    // Getter para a idade
    public int getIdade() {
        return idade;
    }
    
    // Setter para a idade
    public void setIdade(int idade) {
        this.idade = idade;
    }
    
    public static void main(String[] args) {
        // Criando uma inst√¢ncia de Pessoa
        Pessoa pessoa = new Pessoa("Jo√£o", 30);
        
        // Utilizando os getters para obter os valores
        System.out.println("Nome: " + pessoa.getNome());
        System.out.println("Idade: " + pessoa.getIdade());
        
        // Utilizando os setters para alterar os valores
        pessoa.setNome("Maria");
        pessoa.setIdade(25);
        
        // Utilizando os getters novamente para obter os novos valores
        System.out.println("Nome atualizado: " + pessoa.getNome());
        System.out.println("Idade atualizada: " + pessoa.getIdade());
    }
}
````
Neste exemplo, a classe Pessoa possui dois atributos privados: nome e idade. Em seguida, temos um construtor que recebe o nome e a idade como par√¢metros e os atribui aos atributos correspondentes.
A classe Pessoa tamb√©m possui m√©todos getters e setters para acessar e modificar os valores dos atributos. Os getters retornam os valores dos atributos, enquanto os setters permitem alterar os valores.
No m√©todo main, criamos uma inst√¢ncia da classe Pessoa chamada pessoa e passamos o nome "Jo√£o" e a idade 30 para o construtor. Em seguida, utilizamos os getters para obter os valores dos atributos e os imprimimos na sa√≠da do console.
Depois, utilizamos os setters para alterar o nome para "Maria" e a idade para 25. Utilizamos novamente os getters para obter os novos valores e os imprimimos na sa√≠da do console.
Dessa forma, os m√©todos getters e setters permitem acessar e modificar os atributos da classe de forma controlada, mantendo a encapsula√ß√£o e permitindo um c√≥digo mais seguro e flex√≠vel.

* **( 6.1.2.5 ) USO DO FINAL:**
Em POO, a palavra-chave "final" √© usada para modificar elementos de uma classe, indicando que eles n√£o podem ser alterados ou estendidos posteriormente. Existem tr√™s contextos principais em que a palavra-chave "final" pode ser utilizada em uma classe:

* **‚õîNA CLASSE:** Quando uma classe √© declarada como final, significa que ela n√£o pode ser herdada por outras classes. Isso impede que outras classes estendam essa classe final. √â √∫til quando se deseja impedir que uma classe seja estendida ou modificada, garantindo que ela mantenha seu comportamento e estrutura original. Exemplo:
   ```
   final class MinhaClasseFinal {
       // Implementa√ß√£o da classe
   }
   ```

* **‚õîNO METODO:** Quando um m√©todo √© declarado como final em uma classe, significa que ele n√£o pode ser sobrescrito por subclasses. Isso impede que m√©todos sejam modificados ou substitu√≠dos por classes derivadas. √â √∫til quando se deseja garantir que o comportamento do m√©todo n√£o seja alterado nas subclasses. Exemplo:
   ```
   class MinhaClasse {
       final void meuMetodoFinal() {
           // Implementa√ß√£o do m√©todo
       }
   }
   ```

* **‚õîNA VARIAVEL:** Quando uma vari√°vel √© declarada como final, significa que seu valor n√£o pode ser alterado ap√≥s a atribui√ß√£o inicial. Uma vez que uma vari√°vel final recebe um valor, ela se torna constante e n√£o pode ser modificada posteriormente. Isso √© √∫til quando se deseja definir constantes ou valores imut√°veis. Exemplo:
   ```
   class MinhaClasse {
       final int minhaVariavelFinal = 10;
   }
   ```
O uso da palavra-chave "final" em classes, m√©todos ou vari√°veis pode trazer benef√≠cios, como maior seguran√ßa, preven√ß√£o de erros e garantia de comportamento consistente. No entanto, deve-se ter cuidado ao usar "final", pois isso restringe a flexibilidade e extensibilidade do c√≥digo. Deve-se considerar cuidadosamente se √© apropriado e necess√°rio tornar um elemento final em uma classe.

#### ( 6.2.3 ) HERAN√áA:
√â o processo de criar uma nova classe baseada em uma classe existente - a nova classe herda os atributos e m√©todos da classe pai. A heran√ßa permite que uma classe filha aproveite a implementa√ß√£o de uma classe m√£e. Isso torna o c√≥digo mais f√°cil de escrever, j√° que a classe filha n√£o precisa redefinir os m√©todos que j√° foram criados na classe m√£e. A heran√ßa tamb√©m ajuda a organizar as classes em hierarquias.
````
// Classe base (superclasse)
class Animal {
    private String nome;
    
    public Animal(String nome) {
        this.nome = nome;
    }
    
    public void emitirSom() {
        System.out.println("O animal est√° emitindo um som.");
    }
    
    public void dormir() {
        System.out.println("O animal est√° dormindo.");
    }
    
    public String getNome() {
        return nome;
    }
}

// Classe derivada (subclasse)
class Cachorro extends Animal {
    public Cachorro(String nome) {
        super(nome);
    }
    
    public void latir() {
        System.out.println("O cachorro est√° latindo.");
    }
}

// Exemplo de heran√ßa em Java
public class ExemploHeranca {
    public static void main(String[] args) {
        Cachorro cachorro = new Cachorro("Bob");
        
        System.out.println("Nome do cachorro: " + cachorro.getNome());
        cachorro.emitirSom();
        cachorro.latir();
        cachorro.dormir();
    }
}
````
Neste exemplo, temos uma classe base chamada Animal, que possui um atributo nome, um construtor e alguns m√©todos. A classe Animal √© a superclasse.
Em seguida, temos uma classe derivada chamada Cachorro, que herda da classe Animal. A classe Cachorro possui seu pr√≥prio construtor e um m√©todo adicional chamado latir. A classe Cachorro √© a subclasse.
No m√©todo main, criamos uma inst√¢ncia da classe Cachorro chamada cachorro. Podemos chamar m√©todos tanto da classe Animal quanto da classe Cachorro usando essa inst√¢ncia.
Ao executar o c√≥digo, voc√™ ver√° a sa√≠da que exibe o nome do cachorro, seguido por "O animal est√° emitindo um som.", "O cachorro est√° latindo." e "O animal est√° dormindo.". Isso demonstra o conceito de heran√ßa, onde a classe Cachorro herda os m√©todos e atributos da classe Animal e tamb√©m adiciona seu pr√≥prio comportamento espec√≠fico.
A heran√ßa permite reutilizar c√≥digo, criar relacionamentos entre classes e criar hierarquias de classes mais complexas. Ela √© um dos princ√≠pios fundamentais da programa√ß√£o orientada a objetos.

#### ( 6.2.4 ) POLIMORFISMO:
√â a capacidade de um objeto se comportar de v√°rias maneiras diferentes. O objetivo do polimorfismo √© escrever um c√≥digo mais flex√≠vel e gen√©rico. O polimorfismo pode ocorrer de diferentes maneiras: por sobrecarga de m√©todo (quando um m√©todo tem o mesmo nome, mas diferentes par√¢metros), por sobreposi√ß√£o de m√©todo (quando um m√©todo tem o mesmo nome e par√¢metros em diferentes classes da hierarquia) e por interfaces (quando v√°rias classes compartilham um conjunto comum de m√©todos).
````
// Classe base (superclasse)
abstract class Animal {
    public abstract void emitirSom();
}

// Classes derivadas (subclasses)
class Cachorro extends Animal {
    public void emitirSom() {
        System.out.println("O cachorro est√° latindo.");
    }
}

class Gato extends Animal {
    public void emitirSom() {
        System.out.println("O gato est√° miando.");
    }
}

// Exemplo de polimorfismo em Java
public class ExemploPolimorfismo {
    public static void main(String[] args) {
        Animal cachorro = new Cachorro();
        Animal gato = new Gato();
        
        cachorro.emitirSom();  // Sa√≠da: O cachorro est√° latindo.
        gato.emitirSom();      // Sa√≠da: O gato est√° miando.
    }
}
````
Neste exemplo, temos uma classe base abstrata chamada Animal, que possui um m√©todo abstrato emitirSom(). Essa classe base √© estendida por duas classes derivadas concretas: Cachorro e Gato. Ambas as classes derivadas implementam o m√©todo emitirSom() de acordo com o seu comportamento espec√≠fico.
No m√©todo main, criamos inst√¢ncias das classes Cachorro e Gato, mas as referenciamos como objetos da classe base Animal. Isso permite que tratemos esses objetos de forma polim√≥rfica, ou seja, podemos usar a mesma interface (m√©todo emitirSom()) para objetos de diferentes classes.
Ao chamar o m√©todo emitirSom() nos objetos cachorro e gato, o comportamento apropriado √© invocado de acordo com o tipo real do objeto. Isso demonstra o polimorfismo, onde objetos de diferentes classes respondem de maneira diferente ao mesmo m√©todo.
O polimorfismo permite escrever c√≥digo mais flex√≠vel, extens√≠vel e reutiliz√°vel, pois podemos tratar objetos de diferentes classes de maneira uniforme, utilizando uma interface comum.

Existem dois tipos principais de polimorfismo: polimorfismo de subtipo (ou polimorfismo de heran√ßa) e polimorfismo de sobrecarga (ou polimorfismo est√°tico).

* **( 6.2.4.1 ) POLIMORFISMO DE SOBREPOSI√á√ÉO:**
* O polimorfismo de sobreposi√ß√£o ou subtipo ocorre quando uma classe filha √© tratada como uma classe pai. Isso significa que um objeto de uma classe filha pode ser atribu√≠do a uma vari√°vel do tipo da classe pai. O polimorfismo de subtipo √© alcan√ßado por meio da heran√ßa. Exemplo:
   ```
   class Animal {
       public void fazerSom() {
           System.out.println("O animal est√° fazendo um som.");
       }
   }

   class Cachorro extends Animal {
       @Override
       public void fazerSom() {
           System.out.println("O cachorro est√° latindo.");
       }
   }

   class Gato extends Animal {
       @Override
       public void fazerSom() {
           System.out.println("O gato est√° miando.");
       }
   }

   public class Main {
       public static void main(String[] args) {
           Animal animal1 = new Cachorro();
           Animal animal2 = new Gato();

           animal1.fazerSom();  // Resultado: "O cachorro est√° latindo."
           animal2.fazerSom();  // Resultado: "O gato est√° miando."
       }
   }
   ```
Neste exemplo, temos uma classe `Animal` como classe pai e as classes `Cachorro` e `Gato` como classes filhas. Cada classe filha sobrescreve o m√©todo `fazerSom()` da classe pai com sua pr√≥pria implementa√ß√£o. No m√©todo `main()`, criamos objetos das classes filhas e os atribu√≠mos a vari√°veis do tipo da classe pai. Em seguida, chamamos o m√©todo `fazerSom()`, e o comportamento polim√≥rfico ocorre, executando a implementa√ß√£o apropriada de cada classe filha.

* **( 6.2.4.2 ) POLIMORFISMO DE SOBRECARGA:**
* O polimorfismo de sobrecarga ocorre quando uma classe possui v√°rios m√©todos com o mesmo nome, mas com par√¢metros diferentes. A escolha do m√©todo a ser executado √© determinada pelos tipos e pela quantidade de par√¢metros passados durante a chamada do m√©todo. Exemplo:
   ```
   class Calculadora {
       public int somar(int num1, int num2) {
           return num1 + num2;
       }

       public double somar(double num1, double num2) {
           return num1 + num2;
       }
   }

   public class Main {
       public static void main(String[] args) {
           Calculadora calculadora = new Calculadora();
           int resultadoInteiro = calculadora.somar(5, 3);
           double resultadoDouble = calculadora.somar(2.5, 4.7);

           System.out.println(resultadoInteiro);  // Resultado: 8
           System.out.println(resultadoDouble);   // Resultado: 7.2
       }
   }
   ```
Neste exemplo, a classe `Calculadora` possui dois m√©todos `somar()`: um para somar dois n√∫meros inteiros e outro para somar dois n√∫meros decimais (double). Durante a chamada dos m√©todos `somar()`, o Java determina qual vers√£o do m√©todo deve ser executada com base nos tipos dos argumentos passados.

Esses s√£o exemplos b√°sicos dos dois tipos de polimorfismo em POO. O polimorfismo permite escrever c√≥digo mais flex√≠vel, reutiliz√°vel e extens√≠vel, aumentando a modularidade e a capacidade de manuten√ß√£o do sistema.
