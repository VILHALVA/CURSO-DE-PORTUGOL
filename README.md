# CURSO-DE-ALGORITMO
üë®‚Äç‚öñÔ∏èCURSO DE L√ìGICA DE PROGRAMA√á√ÉO COM PYTHON E PORTUGOL.

[![GitHub Repo stars](https://img.shields.io/badge/VILHALVA-GITHUB-03A9F4?logo=github)](https://github.com/VILHALVA) 
[![GitHub Repo stars](https://img.shields.io/badge/CURSO-COMPRETO-03A9F4?logo=youtube)](https://youtube.com/playlist?list=PLHz_AreHm4dmSj0MHol_aoNYCSGFqvfXV) <br>

[![GitHub Repo stars](https://img.shields.io/badge/VEJA%20DOCUMENTA√á√ÉO-PYTHON-03A9F4?logo=google)](https://docs.python.org/3/)
[![GitHub Repo stars](https://img.shields.io/badge/CONHE√áA%20PORTUGOL-STUDIO-03A9F4?logo=google)](http://lite.acad.univali.br/portugol/)

<img src="https://cdn-icons-png.flaticon.com/256/9670/9670741.png" align="center" width="250"> <br>

# üë®‚ÄçüíªOBSERVA√á√ÉO:
* üî∞ Na √©poca que fiz esse curso, n√£o tinha computador. √â por isso que o fiz primeiro em Python (Estudei Python antes de Algoritmos). Consegui fazer o curso em Python numa boa usando o celular.
* üî∞ Hoje (22/05/2023) Decedir liberar tamb√©m o mesmo curso em Portugol.
* üî∞ Vale salientar que fiz a tradu√ß√£o baseada no Python (Pode ter ocorrido de algumas palavras n√£o terem sido traduzidas corretamente - Por isso recomendo que o fa√ßa em Python - Portugol √© apenas para compara√ß√£o - Caso queira usar, n√£o se esque√ßa de fazer os ajustes).
* üî∞ N√£o fiz o curso de Portugol novamente porque j√° sei programar em v√°rias linguagens e n√£o tenho tempo.
* ‚úÖ [BAIXE OS PACOTES DO CURSO AQUI](https://www.cursoemvideo.com/curso/curso-de-algoritmo/)

# [TEM√ÅTICAS](https://youtube.com/playlist?list=PLHz_AreHm4dmSj0MHol_aoNYCSGFqvfXV)
* ‚úÖ [USANDO O SCRATCH](https://scratch.mit.edu/)
* ‚úÖ Vari√°veis simples
* ‚úÖ Operadores (Aritm√©ticos, L√≥gicos e Relacionais)
* ‚úÖ Estruturas condicionais
* ‚úÖ Estrutura de repeti√ß√£o for (Para)
* ‚úÖ Estrutura de repeti√ß√£o while (Enquanto)
* ‚úÖ Procedimentos (Fun√ß√µes)
* ‚úÖ Vetores (Variaveis Compostas 1)
* ‚úÖ Matrizes (Variaveis Compostas 2)

# üìöSE APROFUNDANDO MAIS:
## 1 - OPERADORES ARITM√âTICOS:

| SINAL | USADO |
| :---: | :---: |
| + | SOMA |
| - | SUBTRA√á√ÉO | 
| * | MULTIPLICA√á√ÉO | 
| / | DIVIS√ÉO | 
| % | M√ìDULO | 
| ++ | INCREMENTO | 
| -- | DECREMENTO | 

Os operadores aritm√©ticos na programa√ß√£o s√£o utilizados para realizar opera√ß√µes matem√°ticas em valores ou vari√°veis num√©ricas. Eles s√£o usados para adicionar, subtrair, multiplicar, dividir e realizar outras opera√ß√µes comuns em programa√ß√£o. Os operadores aritm√©ticos b√°sicos s√£o:

* **1. Soma (+):** Utilizada para adicionar dois valores ou vari√°veis. Exemplo: a + b.
* **2. Subtra√ß√£o (-):** Utilizada para subtrair um valor ou vari√°vel de outro. Exemplo: a - b.
* **3. Multiplica√ß√£o (*):** Utilizada para multiplicar dois valores ou vari√°veis. Exemplo: a * b.
* **4. Divis√£o (/):** Utilizada para dividir um valor ou vari√°vel por outro. Exemplo: a / b.
* **5. M√≥dulo (%):** Utilizada para calcular o resto da divis√£o inteira entre dois valores ou vari√°veis. Exemplo: a % b.

Al√©m dos operadores b√°sicos, tamb√©m temos os operadores de incremento e decremento:

* **1. Incremento (++):** Adiciona 1 ao valor ou vari√°vel. Exemplo: a++.
* **2. Decremento (--):** Subtrai 1 do valor ou vari√°vel. Exemplo: a--.

Tamb√©m √© importante lembrar que, em algumas linguagens de programa√ß√£o, a ordem de preced√™ncia dos operadores aritm√©ticos pode variar. Nesse caso, √© preciso lembrar da regra matem√°tica PEMDAS (ou PEDMAS), que define a ordem de prioridade das opera√ß√µes matem√°ticas: par√™nteses, exponencia√ß√£o, multiplica√ß√£o e divis√£o (da esquerda para a direita), e adi√ß√£o e subtra√ß√£o (da esquerda para a direita).

Por exemplo, na express√£o 2 + 3 * 4, a multiplica√ß√£o ser√° realizada antes da soma, resultando em 14. Para for√ßar a soma a ser realizada antes, deve-se usar par√™nteses: (2 + 3) * 4, resultando em 20.

Em resumo, os operadores aritm√©ticos s√£o importantes na programa√ß√£o e s√£o amplamente utilizados para realizar c√°lculos e outras opera√ß√µes matem√°ticas de forma eficiente e precisa.

## 2 - OPERADORES RELACIONAIS:

| SINAL | USADO |
:---: | :---: |
| == | IGUAL |
| != | DIFERENTE |
| > | MAIOR QUE |
| < | MENOR QUE |
| >= | MAIOR OU IGUAL |
| <= | MENOR OU IGUAL |

Os operadores relacionais na programa√ß√£o s√£o utilizados para comparar valores e retornar um valor booleano (verdadeiro ou falso) como resultado. Eles s√£o amplamente utilizados em estruturas de controle de fluxo, que permitem executar diferentes trechos de c√≥digo de acordo com as condi√ß√µes especificadas. Os operadores relacionais comuns s√£o:

* **1. Igual (==):** Utilizado para comparar se dois valores ou vari√°veis s√£o iguais. Exemplo: a == b.
* **2. Diferente (!=):** Utilizado para comparar se dois valores ou vari√°veis s√£o diferentes. Exemplo: a != b.
* **3. Maior que (>):** Utilizado para comparar se um valor ou vari√°vel √© maior que outro. Exemplo: a > b.
* **4. Maior ou igual que (>=):** Utilizado para comparar se um valor ou vari√°vel √© maior ou igual a outro. Exemplo: a >= b.
* **5. Menor que (<):** Utilizado para comparar se um valor ou vari√°vel √© menor que outro. Exemplo: a < b.
* **6. Menor ou igual que (<=):** Utilizado para comparar se um valor ou vari√°vel √© menor ou igual a outro. Exemplo: a <= b.

O resultado de uma compara√ß√£o utilizando um operador relacional √© sempre um valor booleano, que pode ser verdadeiro (true) ou falso (false). Esse resultado pode ser usado como condi√ß√£o para estruturas de controle de fluxo, como o condicional "if" ou o loop "while".

√â importante lembrar que os operadores relacionais n√£o alteram os valores ou vari√°veis em quest√£o, apenas os comparam. Al√©m disso, alguns tipos de dados podem ser comparados com alguns operadores relacionais e outros n√£o. Por exemplo, √© poss√≠vel comparar dois n√∫meros inteiros utilizando todos os operadores relacionais, mas n√£o √© poss√≠vel comparar diretamente duas strings utilizando o operador maior que (>). Nesse caso, √© necess√°rio utilizar m√©todos especiais para realizar compara√ß√µes de strings.

Em resumo, os operadores relacionais s√£o importantes na programa√ß√£o e s√£o amplamente utilizados em estruturas de controle de fluxo para avaliar condi√ß√µes e tomar decis√µes com base nos resultados.

## 3 - OPERADORES L√ìGICOS:

| ABREV | SIMBOLO | SIGNIFICADO | BOOLEANO |
:---: | :---: | :---: | :---:|
| AND | (&&) | E | TRUE TRUE |
| OR | (‚Äñ) | OU | TRUE FALSE |
| NOT | (!) | N√ÉO | FALSE FALSE |

Os operadores l√≥gicos s√£o usados na programa√ß√£o para combinar, comparar e modificar valores booleanos. Existem tr√™s operadores l√≥gicos principais:

* **1. AND (&&):** Retorna true se ambas as express√µes s√£o verdadeiras.
Exemplo:
````
if (a > 5 && b < 3) {
¬†¬† // c√≥digo a ser executado quando ambas as condi√ß√µes s√£o verdadeiras
}
````

* **2. OR (||):** Retorna true se pelo menos uma das express√µes √© verdadeira.
Exemplo:
````
if (a == 5 ‚Äñ b == 3) {
¬†¬† // c√≥digo a ser executado quando pelo menos uma das condi√ß√µes √© verdadeira
}
````

* **3. NOT (!):** Inverte o valor booleano, retornando true se a express√£o √© falsa e false se a express√£o √© verdadeira.
Exemplo:
````
if (!(a > 5)) {
¬†¬† // c√≥digo a ser executado quando a express√£o √© falsa
}
````

Os operadores l√≥gicos s√£o comumente usados junto com operadores relacionais (como <, >, <=, >=, ==, !=) para criar condi√ß√µes mais complexas que ajudam o programa a tomar decis√µes com base em v√°rias vari√°veis.

## 4) OPERADOR UN√ÅRIO:
Operador un√°rio √© um operador matem√°tico utilizado em programa√ß√£o que atua em apenas um operando, ao contr√°rio dos operadores bin√°rios, que atuam sobre dois operandos. Na programa√ß√£o, os operadores un√°rios s√£o usados para realizar opera√ß√µes em um √∫nico valor ou vari√°vel. Existem v√°rios tipos de operadores un√°rios, incluindo:

**1. Operadores aritm√©ticos, que realizam opera√ß√µes matem√°ticas simples em um √∫nico valor ou vari√°vel, como incrementos/decrementos e nega√ß√£o:**

* ++: incremento. Adiciona 1 ao valor ou vari√°vel;
* --: decremento. Subtrai 1 do valor ou vari√°vel;
* +: positivo. N√£o faz nada, apenas mant√©m o sinal do valor ou vari√°vel;
* -: negativo. Inverte o sinal do valor ou vari√°vel.

**2. Operadores l√≥gicos, que s√£o usados para avaliar valores booleanos:**

* !: nega√ß√£o l√≥gica. Inverte o valor booleano de true para false ou vice-versa.

**3. Operadores de endere√ßo e ponteiro, que s√£o usados para acessar endere√ßos de mem√≥ria:**
* &: endere√ßo de. Retorna o endere√ßo de mem√≥ria de uma vari√°vel;
* *\: ponteiro. Retorna o valor armazenado no endere√ßo de mem√≥ria de uma vari√°vel.

**4. Operadores de convers√£o de tipos, que convertem um valor de um tipo de dados para outro:**

* (tipo): convers√£o de tipo. Converte o valor ou vari√°vel para o tipo especificado.

* Em resumo, os operadores un√°rios s√£o importantes em programa√ß√£o e s√£o amplamente utilizados em diferentes linguagens para realizar opera√ß√µes matem√°ticas, l√≥gicas, de endere√ßo, de conver√ß√£o de tipos e outras opera√ß√µes sobre um √∫nico valor ou vari√°vel.

## 5) OPERADOR TERN√ÅRIO:
Operador tern√°rio √© um operador condicional presente em algumas linguagens de programa√ß√£o, como C, C++, Java, Python, entre outras. Ele √© geralmente utilizado em situa√ß√µes que envolvem questionamentos condicionais, onde o resultado pode ser um ou outro valor.
A sintaxe do operador tern√°rio √© tipicamente:

````
(condi√ß√£o) ? valor_se_verdadeiro : valor_se_falso;
````

Onde:
* Condi√ß√£o: √© a express√£o que ser√° avaliada como verdadeira ou falsa;
* Valorseverdadeiro: √© o valor que ser√° retornado se a condi√ß√£o for verdadeira;
* Valorsefalso: √© o valor que ser√° retornado se a condi√ß√£o for falsa.

O operador tern√°rio √© uma forma condensada de escrever um c√≥digo que seria feito com a estrutura de if-else. Ao inv√©s de escrever um bloco de condi√ß√µes if-else, voc√™ pode usar o operador tern√°rio para executar a opera√ß√£o de acordo com o valor true ou false resultante da condi√ß√£o.

Um exemplo de uso do operador tern√°rio √©:

````
int a = 10;
String mensagem = (a > 5) ? "O valor de a √© maior que 5" : "O valor de a √© menor que 5";
System.out.println(mensagem);
````

Nesse exemplo, a vari√°vel a recebe o valor 10. A condi√ß√£o (a > 5) √© avaliada como true, ent√£o a vari√°vel mensagem recebe o valor "O valor de a √© maior que 5". Caso a condi√ß√£o fosse avaliada como false, a vari√°vel mensagem receberia o valor "O valor de a √© menor que 5".

O operador tern√°rio √© uma ferramenta √∫til para simplificar o c√≥digo e torn√°-lo mais leg√≠vel e conciso, mas √© importante us√°-lo com modera√ß√£o e de forma adequada, para n√£o comprometer a facilidade de entendimento do c√≥digo.

## 6) VARI√ÅVEIS SIMPLES:

As vari√°veis simples s√£o vari√°veis que armazenam um √∫nico valor em um determinado momento. Esses tipos de vari√°veis armazenam valores de tipos de dados b√°sicos, como inteiros, reais, caracteres, booleanos, entre outros, dependendo da linguagem de programa√ß√£o.

Por exemplo, uma vari√°vel "int x" pode armazenar um √∫nico valor do tipo inteiro em um determinado momento. Outra vari√°vel "float y" pode armazenar um valor real de ponto flutuante.

As vari√°veis simples s√£o essenciais para a programa√ß√£o e s√£o usadas amplamente em todos os tipos de algoritmos e opera√ß√µes. Elas s√£o frequentemente utilizadas para armazenar valores de entrada do usu√°rio, resultados de c√°lculos, contadores de loops e √≠ndices de matrizes ou arrays.

Ao contr√°rio das vari√°veis compostas, uma vari√°vel simples n√£o pode armazenar conjuntos inteiros de valores relacionados de maneira eficiente. Se voc√™ precisar armazenar muitos valores relacionados, seria necess√°rio criar v√°rias vari√°veis simples distintas para armazen√°-los. Por exemplo, se voc√™ quiser armazenar o nome, sobrenome, endere√ßo e idade de uma pessoa, seria necess√°rio criar quatro vari√°veis simples um para cada atributo. Exemplo:
````
// Exemplo de vari√°veis simples em Java
public class ExemploVariaveis {
    public static void main(String[] args) {
        // Declara√ß√£o e atribui√ß√£o de vari√°veis
        int idade = 25;
        double altura = 1.75;
        char genero = 'M';
        boolean ehEstudante = true;
        String nome = "Jo√£o";

        // Utiliza√ß√£o das vari√°veis
        System.out.println("Nome: " + nome);
        System.out.println("Idade: " + idade);
        System.out.println("Altura: " + altura);
        System.out.println("G√™nero: " + genero);
        System.out.println("√â estudante? " + ehEstudante);
    }
}
````

## 7) VARI√ÅVEIS COMPOSTAS:

Vari√°veis compostas na programa√ß√£o s√£o tipos de dados que podem armazenar um conjunto de valores relacionados como se fossem um √∫nico valor. Esses tipos incluem arrays, listas, matrizes, tuplas, dicion√°rios, entre outros, dependendo da linguagem de programa√ß√£o utilizada.

* **1) ARRAY:** √â uma vari√°vel composta que pode armazenar uma sequ√™ncia de valores do mesmo tipo em uma √∫nica vari√°vel. Cada valor no array pode ser acessado por seu √≠ndice, que come√ßa em 0.
````
// Exemplo de array em Java
public class ExemploArray {
    public static void main(String[] args) {
        // Declara√ß√£o e inicializa√ß√£o de um array de inteiros
        int[] numeros = {1, 2, 3, 4, 5};

        // Acessando elementos do array
        System.out.println(numeros[0]);  // Sa√≠da: 1
        System.out.println(numeros[2]);  // Sa√≠da: 3

        // Modificando um elemento do array
        numeros[0] = 10;
        System.out.println(numeros[0]);  // Sa√≠da: 10

        // Percorrendo o array com um loop for
        for (int i = 0; i < numeros.length; i++) {
            System.out.println(numeros[i]);
        }
    }
}
````

* **2) LISTA:** √â uma vari√°vel composta que pode armazenar uma sequ√™ncia de valores arbitr√°rios de diferentes tipos de dados. Os itens na lista tamb√©m podem ser acessados por seus √≠ndices n√∫mericos, assim como em um array.
````
import java.util.ArrayList;

// Exemplo de ArrayList em Java
public class ExemploArrayList {
    public static void main(String[] args) {
        // Declara√ß√£o e inicializa√ß√£o de um ArrayList de Strings
        ArrayList<String> nomes = new ArrayList<>();

        // Adicionando elementos ao ArrayList
        nomes.add("Jo√£o");
        nomes.add("Maria");
        nomes.add("Pedro");

        // Acessando elementos do ArrayList
        System.out.println(nomes.get(0));  // Sa√≠da: "Jo√£o"
        System.out.println(nomes.get(2));  // Sa√≠da: "Pedro"

        // Modificando um elemento do ArrayList
        nomes.set(0, "Lucas");
        System.out.println(nomes.get(0));  // Sa√≠da: "Lucas"

        // Percorrendo o ArrayList com um loop for-each
        for (String nome : nomes) {
            System.out.println(nome);
        }
    }
}
````

* **3) DICION√ÅRIOS:** S√£o vari√°veis compostas mais complexas que armazenam valores em pares chave-valor, permitindo que os valores sejam acessados por sua chave, em vez de um √≠ndice. 
````
// Exemplo de dicion√°rio em JavaScript
let dicionario = {
    "Ma√ß√£": 10,
    "Laranja": 5,
    "Banana": 7
};

// Acessando elementos do dicion√°rio
console.log(dicionario["Ma√ß√£"]);     // Sa√≠da: 10
console.log(dicionario["Laranja"]);  // Sa√≠da: 5

// Modificando um elemento do dicion√°rio
dicionario["Banana"] = 15;
console.log(dicionario["Banana"]);   // Sa√≠da: 15

// Percorrendo o dicion√°rio com um loop for-in
for (let chave in dicionario) {
    console.log(chave + ": " + dicionario[chave]);
}
````

* **4) MATRIZES:** S√£o semelhantes √†s arrays, mas permitem armazenar valores em uma ou mais dimens√µes. As tuplas s√£o semelhantes √†s listas, mas s√£o imut√°veis, o que significa que n√£o podem ser alteradas depois de criadas.
````
// Exemplo de matriz em Java
public class ExemploMatriz {
    public static void main(String[] args) {
        // Declara√ß√£o e inicializa√ß√£o de uma matriz de inteiros
        int[][] matriz = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };

        // Acessando elementos da matriz
        System.out.println(matriz[0][0]);  // Sa√≠da: 1
        System.out.println(matriz[1][2]);  // Sa√≠da: 6

        // Modificando um elemento da matriz
        matriz[2][1] = 10;
        System.out.println(matriz[2][1]);  // Sa√≠da: 10

        // Percorrendo a matriz com loops aninhados
        for (int i = 0; i < matriz.length; i++) {
            for (int j = 0; j < matriz[i].length; j++) {
                System.out.print(matriz[i][j] + " ");
            }
            System.out.println();
        }
    }
}
````

Usando vari√°veis compostas, os programadores podem armazenar e manipular conjuntos de dados relacionados de forma mais eficiente e conveniente do que armazenar cada valor em uma vari√°vel separada.

## 8) ESTRUTURA CONDICIONAL:
As estruturas condicionais s√£o um recurso da programa√ß√£o que permitem a execu√ß√£o de um bloco de c√≥digo baseado em uma condi√ß√£o. Basicamente, a estrutura condicional verifica se uma determinada condi√ß√£o √© verdadeira ou falsa e executa o c√≥digo correspondente.

A estrutura condicional consiste em tr√™s partes principais: a condi√ß√£o, o bloco de c√≥digo que ser√° executado se a condi√ß√£o for verdadeira (bloco "ent√£o"), e o bloco de c√≥digo que ser√° executado se a condi√ß√£o for falsa (bloco "sen√£o").

As duas principais estruturas condicionais s√£o a "if-else" e a "switch-case". Na estrutura "if-else", o c√≥digo dentro do bloco "ent√£o" √© executado somente se a condi√ß√£o for verdadeira. Caso contr√°rio, o c√≥digo dentro do bloco "sen√£o" ser√° executado, se houver um bloque "sen√£o". Exemplo:
````
if (idade >= 18) {
¬†¬† System.out.println("Pode votar!");
} 
else {
¬†¬† System.out.println("Ainda √© jovem para votar.");
}
````

Na estrutura "switch-case", o c√≥digo selecionado para execu√ß√£o depende do valor de uma vari√°vel. √â poss√≠vel ter v√°rios casos no bloco "caso", onde cada caso representa um valor diferente da vari√°vel. Exemplo:
````
switch (nota) {
¬†¬† case 10:
¬†¬†¬†¬†¬† System.out.println("Nota m√°xima!");
¬†¬†¬†¬†¬† break;
¬†¬† case 7:
¬†¬†¬†¬†¬† System.out.println("Aprovado.");
¬†¬†¬†¬†¬† break;
¬†¬† default:
¬†¬†¬†¬†¬† System.out.println("Reprovado.");
}
````

Com essas estruturas condicionais, os programadores podem controlar o fluxo do programa de maneira muito mais eficiente, garantindo que cada bloco de c√≥digo seja executado apenas quando necess√°rio.

## 9) ESTRUTURAS DE REPETI√á√ÉO:
As estruturas de repeti√ß√£o, tamb√©m conhecidas como la√ßos ou loops, s√£o utilizadas em programa√ß√£o para executar um conjunto de instru√ß√µes repetidamente, enquanto uma condi√ß√£o espec√≠fica √© satisfeita. Existem tr√™s principais tipos de loops em programa√ß√£o:

* **1. O loop while:** O while √© utilizado quando n√£o se sabe o n√∫mero exato de vezes que as instru√ß√µes devem ser repetidas. A condi√ß√£o √© testada antes de cada itera√ß√£o do loop, e enquanto a condi√ß√£o permanecer verdadeira, o loop ir√° executar as instru√ß√µes. A estrutura do loop while √© a seguinte:
````
while (condicao) {
¬† // instrucoes
}
````

* **2. O loop do-while:** O do-while √© similar ao loop while, mas a condi√ß√£o √© testada depois de cada itera√ß√£o do loop. Isso significa que, independente da condi√ß√£o, o loop ir√° executar as instru√ß√µes pelo menos uma vez. A estrutura do loop do-while √© a seguinte:
````
do {
¬† // instrucoes
} while (condicao);
````

* **3. O loop for:** O loop for √© utilizado quando se sabe o n√∫mero exato de vezes que o loop deve ser executado. Ele √© composto por tr√™s partes: a inicializa√ß√£o, a condi√ß√£o e a atualiza√ß√£o. A inicializa√ß√£o √© executada apenas uma vez, no in√≠cio do loop. A condi√ß√£o √© testada antes de cada itera√ß√£o do loop e, enquanto a condi√ß√£o permanecer verdadeira, o loop ir√° executar as instru√ß√µes. A atualiza√ß√£o √© executada no final de cada itera√ß√£o do loop. A estrutura do loop for √© a seguinte:
````
for (inicializacao; condicao; atualizacao) {
¬† // instrucoes
}
````

Cada uma dessas estruturas pode ser utilizada para diferentes prop√≥sitos, dependendo da l√≥gica do programa. A escolha da estrutura ideal depende do problema a ser resolvido e da l√≥gica do programa em si. √â importante lembrar que loops mal escritos podem causar problemas como loops infinitos e travamentos do programa, ent√£o √© importante ter cuidado ao implement√°-los.

## 10) FUN√á√ïES OU METODOS:
Uma fun√ß√£o √© uma por√ß√£o de c√≥digo que realiza uma tarefa espec√≠fica e pode ser chamada, ou invocada, em diferentes partes do programa. A fun√ß√£o geralmente recebe um ou mais argumentos como entrada, executa uma s√©rie de opera√ß√µes em cima deles e pode retornar um valor de sa√≠da para o restante do programa.

As fun√ß√µes permitem que os programadores escrevam c√≥digo mais modular e reutiliz√°vel. Ao inv√©s de repetir o mesmo bloco de c√≥digo em v√°rias partes do programa, uma √∫nica fun√ß√£o pode ser criada para realizar essa tarefa e chamada sempre que necess√°rio.

As fun√ß√µes podem ser criadas em quase todas as linguagens de programa√ß√£o. Em linguagens orientadas a objetos, as fun√ß√µes s√£o frequentemente chamadas de m√©todos. As fun√ß√µes podem ser criadas como parte de uma classe ou como fun√ß√µes independentes.

Por exemplo, vamos examinar o seguinte trecho de c√≥digo em Python que ilustra uma fun√ß√£o simples que soma dois n√∫meros e retorna o resultado:
````
def soma(a, b):
¬†¬† resultado = a + b
¬†¬† return resultado
````

Neste exemplo de c√≥digo, a fun√ß√£o "soma" √© criada com dois argumentos, "a" e "b", que ser√£o usados para realizar a opera√ß√£o matem√°tica. Dentro da fun√ß√£o, a opera√ß√£o √© realizada e o resultado √© armazenado na vari√°vel "resultado". A fun√ß√£o retorna o valor de "resultado" para o c√≥digo que a chamou.

As fun√ß√µes podem ser uma √≥tima maneira de tornar o c√≥digo mais f√°cil de ler e manter, ao mesmo tempo que aumentam a modularidade e a reutiliza√ß√£o do c√≥digo.

## 11) PROGRAMA√á√ÉO ORIENTADA A OBJETOS (POO):
A programa√ß√£o orientada a objetos (POO) √© uma abordagem de programa√ß√£o que se baseia no conceito de objetos, que podem conter dados e fun√ß√µes e interagir com outros objetos.

Em POO, os objetos s√£o criados a partir de classes que servem como modelos para definir seus atributos (dados) e m√©todos (fun√ß√µes). Cada objeto, por sua vez, pode ter seu pr√≥prio conjunto de valores de dados exclusivo, mesmo que compartilhe a mesma classe. Al√©m disso, os objetos podem se comunicar com outros objetos atrav√©s de mecanismos de troca de mensagem.

Os quatro pilares da POO s√£o encapsulamento, heran√ßa, polimorfismo e abstra√ß√£o. O encapsulamento √© o princ√≠pio de manter o comportamento interno e a estrutura de um objeto ocultos ao mundo externo e ao c√≥digo que √© escrito fora da classe. A heran√ßa √© o processo de criar uma nova classe baseada em uma classe existente - a nova classe herda os atributos e m√©todos da classe pai. O polimorfismo √© a capacidade de um objeto se comportar de v√°rias maneiras diferentes. E a abstra√ß√£o √© a capacidade de omitir informa√ß√µes detalhadas e irrelevantes e concentrar-se apenas nos aspectos importantes do objeto.

As linguagens de programa√ß√£o orientadas a objetos comuns incluem Java, Python, Ruby, C++ e C#. A maioria dessas linguagens permite a defini√ß√£o de novas classes, bem como a reutiliza√ß√£o de classes existentes atrav√©s da heran√ßa. A programa√ß√£o orientada a objetos √© amplamente utilizada na programa√ß√£o de aplicativos de desktop, jogos, aplicativos para dispositivos m√≥veis, aplicativos web e em muitos outros tipos de software.

A programa√ß√£o orientada a objetos √© uma poderosa abordagem de programa√ß√£o que permite a cria√ß√£o de c√≥digo mais modular e f√°cil de manter. Ela incentiva uma programa√ß√£o mais organizada, promove a reutiliza√ß√£o de c√≥digo e enfatiza a import√¢ncia da clareza e da estrutura√ß√£o do c√≥digo. Exemplo:
````
// Exemplo de classe em Java
public class Pessoa {
    // Vari√°veis de inst√¢ncia
    private String nome;
    private int idade;
    
    // Construtor da classe
    public Pessoa(String nome, int idade) {
        this.nome = nome;
        this.idade = idade;
    }
    
    // M√©todos de inst√¢ncia
    public String getNome() {
        return nome;
    }
    
    public int getIdade() {
        return idade;
    }
    
    public void fazerAniversario() {
        idade++;
    }
    
    // M√©todo main para teste
    public static void main(String[] args) {
        // Criando uma inst√¢ncia da classe Pessoa
        Pessoa pessoa = new Pessoa("Jo√£o", 25);
        
        // Utilizando os m√©todos da inst√¢ncia
        System.out.println("Nome: " + pessoa.getNome());
        System.out.println("Idade: " + pessoa.getIdade());
        
        pessoa.fazerAniversario();
        
        System.out.println("Idade ap√≥s anivers√°rio: " + pessoa.getIdade());
    }
}
````

## 12) QUATRO PILARES DA POO:
Os quatro pilares da programa√ß√£o orientada a objetos s√£o:

* **1. Encapsulamento:** √â o princ√≠pio de manter o comportamento interno e a estrutura de um objeto ocultos ao mundo externo e ao c√≥digo que √© escrito fora da classe. O objetivo desse pilar √© esconder a complexidade dos objetos e proteger o seu estado interno de manipula√ß√µes indevidas. Isso √© feito definindo-se n√≠veis de acesso aos m√©todos e √†s vari√°veis de uma classe, como p√∫blico, privado ou protegido.
````
// Exemplo de encapsulamento em Java
public class Pessoa {
    private String nome;
    private int idade;
    
    // M√©todo getter para o nome
    public String getNome() {
        return nome;
    }
    
    // M√©todo setter para o nome
    public void setNome(String nome) {
        this.nome = nome;
    }
    
    // M√©todo getter para a idade
    public int getIdade() {
        return idade;
    }
    
    // M√©todo setter para a idade
    public void setIdade(int idade) {
        this.idade = idade;
    }
    
    // M√©todo main para teste
    public static void main(String[] args) {
        Pessoa pessoa = new Pessoa();
        
        // Usando os m√©todos getter e setter
        pessoa.setNome("Jo√£o");
        pessoa.setIdade(25);
        
        System.out.println("Nome: " + pessoa.getNome());
        System.out.println("Idade: " + pessoa.getIdade());
    }
}
````
Neste exemplo, a classe Pessoa possui duas vari√°veis de inst√¢ncia nome e idade, que s√£o marcadas como private. Isso significa que essas vari√°veis s√≥ podem ser acessadas dentro da pr√≥pria classe.

Em seguida, a classe fornece m√©todos getter e setter para acessar e modificar essas vari√°veis. Os m√©todos getter permitem obter o valor das vari√°veis, enquanto os m√©todos setter permitem definir novos valores para as vari√°veis.

Dentro do m√©todo main, criamos uma inst√¢ncia da classe Pessoa e utilizamos os m√©todos setter para atribuir valores ao nome e √† idade da pessoa. Em seguida, utilizamos os m√©todos getter para obter os valores e exibimos na sa√≠da do console.

Ao utilizar o encapsulamento, estamos protegendo os detalhes internos da classe e permitindo um acesso controlado aos seus membros. Isso ajuda a manter a integridade dos dados e facilita a manuten√ß√£o do c√≥digo, permitindo uma maior flexibilidade na implementa√ß√£o interna da classe.

* **2. Heran√ßa:** √â o processo de criar uma nova classe baseada em uma classe existente - a nova classe herda os atributos e m√©todos da classe pai. A heran√ßa permite que uma classe filha aproveite a implementa√ß√£o de uma classe m√£e. Isso torna o c√≥digo mais f√°cil de escrever, j√° que a classe filha n√£o precisa redefinir os m√©todos que j√° foram criados na classe m√£e. A heran√ßa tamb√©m ajuda a organizar as classes em hierarquias.
````
// Classe base (superclasse)
class Animal {
    private String nome;
    
    public Animal(String nome) {
        this.nome = nome;
    }
    
    public void emitirSom() {
        System.out.println("O animal est√° emitindo um som.");
    }
    
    public void dormir() {
        System.out.println("O animal est√° dormindo.");
    }
    
    public String getNome() {
        return nome;
    }
}

// Classe derivada (subclasse)
class Cachorro extends Animal {
    public Cachorro(String nome) {
        super(nome);
    }
    
    public void latir() {
        System.out.println("O cachorro est√° latindo.");
    }
}

// Exemplo de heran√ßa em Java
public class ExemploHeranca {
    public static void main(String[] args) {
        Cachorro cachorro = new Cachorro("Bob");
        
        System.out.println("Nome do cachorro: " + cachorro.getNome());
        cachorro.emitirSom();
        cachorro.latir();
        cachorro.dormir();
    }
}
````
Neste exemplo, temos uma classe base chamada Animal, que possui um atributo nome, um construtor e alguns m√©todos. A classe Animal √© a superclasse.

Em seguida, temos uma classe derivada chamada Cachorro, que herda da classe Animal. A classe Cachorro possui seu pr√≥prio construtor e um m√©todo adicional chamado latir. A classe Cachorro √© a subclasse.

No m√©todo main, criamos uma inst√¢ncia da classe Cachorro chamada cachorro. Podemos chamar m√©todos tanto da classe Animal quanto da classe Cachorro usando essa inst√¢ncia.

Ao executar o c√≥digo, voc√™ ver√° a sa√≠da que exibe o nome do cachorro, seguido por "O animal est√° emitindo um som.", "O cachorro est√° latindo." e "O animal est√° dormindo.". Isso demonstra o conceito de heran√ßa, onde a classe Cachorro herda os m√©todos e atributos da classe Animal e tamb√©m adiciona seu pr√≥prio comportamento espec√≠fico.

A heran√ßa permite reutilizar c√≥digo, criar relacionamentos entre classes e criar hierarquias de classes mais complexas. Ela √© um dos princ√≠pios fundamentais da programa√ß√£o orientada a objetos.

* **3. Polimorfismo:** √â a capacidade de um objeto se comportar de v√°rias maneiras diferentes. O objetivo do polimorfismo √© escrever um c√≥digo mais flex√≠vel e gen√©rico. O polimorfismo pode ocorrer de diferentes maneiras: por sobrecarga de m√©todo (quando um m√©todo tem o mesmo nome, mas diferentes par√¢metros), por sobreposi√ß√£o de m√©todo (quando um m√©todo tem o mesmo nome e par√¢metros em diferentes classes da hierarquia) e por interfaces (quando v√°rias classes compartilham um conjunto comum de m√©todos).
````
// Classe base (superclasse)
abstract class Animal {
    public abstract void emitirSom();
}

// Classes derivadas (subclasses)
class Cachorro extends Animal {
    public void emitirSom() {
        System.out.println("O cachorro est√° latindo.");
    }
}

class Gato extends Animal {
    public void emitirSom() {
        System.out.println("O gato est√° miando.");
    }
}

// Exemplo de polimorfismo em Java
public class ExemploPolimorfismo {
    public static void main(String[] args) {
        Animal cachorro = new Cachorro();
        Animal gato = new Gato();
        
        cachorro.emitirSom();  // Sa√≠da: O cachorro est√° latindo.
        gato.emitirSom();      // Sa√≠da: O gato est√° miando.
    }
}
````
Neste exemplo, temos uma classe base abstrata chamada Animal, que possui um m√©todo abstrato emitirSom(). Essa classe base √© estendida por duas classes derivadas concretas: Cachorro e Gato. Ambas as classes derivadas implementam o m√©todo emitirSom() de acordo com o seu comportamento espec√≠fico.

No m√©todo main, criamos inst√¢ncias das classes Cachorro e Gato, mas as referenciamos como objetos da classe base Animal. Isso permite que tratemos esses objetos de forma polim√≥rfica, ou seja, podemos usar a mesma interface (m√©todo emitirSom()) para objetos de diferentes classes.

Ao chamar o m√©todo emitirSom() nos objetos cachorro e gato, o comportamento apropriado √© invocado de acordo com o tipo real do objeto. Isso demonstra o polimorfismo, onde objetos de diferentes classes respondem de maneira diferente ao mesmo m√©todo.

O polimorfismo permite escrever c√≥digo mais flex√≠vel, extens√≠vel e reutiliz√°vel, pois podemos tratar objetos de diferentes classes de maneira uniforme, utilizando uma interface comum.

* **4. Abstra√ß√£o:** √â a capacidade de omitir informa√ß√µes detalhadas e irrelevantes e concentrar-se apenas nos aspectos importantes do objeto. O objetivo da abstra√ß√£o √© estabelecer uma forma mais simples e gen√©rica de se pensar nos objetos. Isso √© feito identificando os aspectos mais importantes de um objeto e modelando-o em uma classe. A abstra√ß√£o pode ser alcan√ßada por meio de classes abstratas e interfaces, que permitem a especifica√ß√£o dos m√©todos e atributos que uma classe deve implementar sem fornecer uma implementa√ß√£o real.
````
// Classe abstrata
abstract class Animal {
    private String nome;
    
    public Animal(String nome) {
        this.nome = nome;
    }
    
    // M√©todo abstrato
    public abstract void emitirSom();
    
    // M√©todo concreto
    public void dormir() {
        System.out.println("O animal est√° dormindo.");
    }
    
    // Getter para o nome
    public String getNome() {
        return nome;
    }
}

// Classe concreta
class Cachorro extends Animal {
    public Cachorro(String nome) {
        super(nome);
    }
    
    public void emitirSom() {
        System.out.println("O cachorro est√° latindo.");
    }
}

// Exemplo de abstra√ß√£o em Java
public class ExemploAbstracao {
    public static void main(String[] args) {
        Cachorro cachorro = new Cachorro("Rex");
        
        System.out.println("Nome do cachorro: " + cachorro.getNome());
        cachorro.emitirSom();  // Sa√≠da: O cachorro est√° latindo.
        cachorro.dormir();     // Sa√≠da: O animal est√° dormindo.
    }
}
````
Neste exemplo, temos uma classe abstrata chamada Animal, que cont√©m um m√©todo abstrato emitirSom(). Essa classe abstrata tamb√©m possui um m√©todo concreto dormir() e um atributo nome.

A classe concreta Cachorro estende a classe abstrata Animal e implementa o m√©todo abstrato emitirSom() de acordo com o comportamento espec√≠fico do cachorro.

No m√©todo main, criamos uma inst√¢ncia da classe Cachorro chamada cachorro. Podemos chamar o m√©todo emitirSom() e o m√©todo dormir() da classe Animal usando essa inst√¢ncia.

A classe abstrata Animal serve como um modelo gen√©rico para representar animais e define a estrutura b√°sica comum para todas as classes derivadas. As classes concretas, como Cachorro, implementam os detalhes espec√≠ficos do comportamento.

A abstra√ß√£o nos permite representar conceitos gen√©ricos e definir comportamentos comuns em classes abstratas, enquanto as classes concretas fornecem a implementa√ß√£o espec√≠fica desses comportamentos. A abstra√ß√£o nos ajuda a criar um c√≥digo mais flex√≠vel, reutiliz√°vel e de f√°cil manuten√ß√£o.

## 13) OS M√âTODOS GETTERS, SETTERS E CONSTRUTOR:
Os m√©todos getters e setters s√£o utilizados em programa√ß√£o orientada a objetos para acessar e modificar os atributos de um objeto de classe. Os getters, ou acessores, s√£o m√©todos que retornam o valor de um atributo enquanto os setters, ou modificadores, s√£o m√©todos que definem o valor de um atributo. Eles s√£o importantes para manter a privacidade e a seguran√ßa dos dados de uma classe, garantindo que o acesso aos atributos seja controlado.

Por exemplo, suponha que eu tenha uma classe chamada "Pessoa" que tem um atributo "idade". O m√©todo getter para o atributo idade seria escrito como:
````
public int getIdade() {
¬† return idade;
}
````

E o m√©todo setter seria escrito da seguinte forma:
````
public void setIdade(int novaIdade) {
¬† idade = novaIdade;
}
````

O construtor √© um m√©todo especial que √© utilizado para criar objetos de uma classe. Ele √© invocado automaticamente quando um novo objeto √© criado e √© respons√°vel por definir os valores iniciais dos atributos. Em Java, o construtor tem o mesmo nome da classe.

Por exemplo, o construtor da classe Pessoa pode ser escrito assim:
````
public Pessoa(String nome, int idade) {
¬† this.nome = nome;
¬† this.idade = idade;
}
````

Neste caso, o construtor recebe dois argumentos (o nome e a idade da pessoa) e inicializa os atributos correspondentes. O "this" √© utilizado para referenciar o objeto atual que est√° sendo criado.
